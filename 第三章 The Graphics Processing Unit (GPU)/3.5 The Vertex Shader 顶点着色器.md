## 3.5 The Vertex Shader 顶点着色器

The vertex shader is the first stage in the functional pipeline shown in Figure 3.2.While this is the first stage directly under programmer control, it is worth noting that some data manipulation happens before this stage. In what DirectX calls the input assembler [175, 530, 1208], several streams of data can be woven together to form the sets of vertices and primitives sent down the pipeline. For example, an object could be represented by one array of positions and one array of colors. The input assembler would create this object’s triangles (or lines or points) by creating vertices with positions and colors. A second object could use the same array of positions (along with a different model transform matrix) and a different array of colors for its representation. Data representation is discussed in detail in Section 16.4.5. There is also support in the input assembler to perform instancing. This allows an object to be drawn several times with some varying data per instance, all with a single draw call. The use of instancing is covered in Section 18.4.2.

顶点着色器是图 3.2 中所示功能管道中的第一阶段。虽然这是程序员直接控制的第一阶段，但值得注意的是，在此阶段之前会发生一些数据操作。 在 DirectX 所称的输入汇编器(input assembler) [175、530、1208] 中，可以将多个数据流交织在一起，形成沿管线发送的顶点和图元集。 例如，一个对象可以由一个位置数组和一个颜色数组表示。 输入汇编程序(input assembler)将通过创建具有位置和颜色的顶点来创建该对象的三角形（或线或点）。 第二个对象可以使用相同的位置数组（以及不同的模型变换矩阵）和不同的颜色数组来表示。 数据表示在第 16.4.5 节中详细讨论。 输入汇编器也支持实现实例化(perform instancing)。 这允许使用每个实例的一些不同数据多次绘制对象，所有这些都通过一次绘制**调用**完成。 实例化的使用在第 18.4.2 节中介绍。

A triangle mesh is represented by a set of vertices, each associated with a specific position on the model surface. Besides position, there are other optional properties associated with each vertex, such as a color or texture coordinates. Surface normals are defined at mesh vertices as well, which may seem like an odd choice. Mathematically, each triangle has a well-defined surface normal, and it may seem to make more sense to use the triangle’s normal directly for shading. However, when rendering, triangle meshes are often used to represent an underlying curved surface, and vertex normals are used to represent the orientation of this surface, rather than that of the triangle mesh itself. Section 16.3.4 will discuss methods to compute vertex normals. Figure 3.7 shows side views of two triangle meshes that represent curved surfaces, one smooth and one with a sharp crease.

三角形网格由一组顶点表示，每个顶点与模型表面上的特定位置相关联。 除了位置之外，每个顶点还有其他可选属性，例如颜色或纹理坐标。 表面法线也在网格(mesh)顶点处定义，这似乎是一个奇怪的选择。 从数学上讲，每个三角形都有明确定义的表面法线，直接使用三角形的法线进行着色似乎更有意义。 然而，在渲染时，三角形网格(mesh)通常用于表示底层曲面，顶点法线用于表示该曲面(surface)的方向，而不是三角形网格本身的方向。 16.3.4 节将讨论计算顶点法线的方法。 图 3.7 显示了代表曲面的两个三角形网格的侧视图，一个是光滑的，一个是锐利的折痕。

![3.7](https://img-blog.csdnimg.cn/27da889d565b4ea5a09ba6150c854b6b.png)


> Figure 3.7. Side views of triangle meshes (in black, with vertex normals) representing curved surfaces (in red). On the left smoothed vertex normals are used to represent a smooth surface. On the right the middle vertex has been duplicated and given two normals, representing a crease.
> 图 3.7。 表示曲面（红色）的三角形网格（黑色，顶点法线）的侧视图。 在左侧，平滑的顶点法线用于表示光滑的表面。 在右侧，中间顶点已被复制并赋予两条法线，代表折痕。

The vertex shader is the first stage to process the triangle mesh. The data describing what triangles are formed is unavailable to the vertex shader. As its name implies, it deals exclusively with the incoming vertices. The vertex shader provides a way to modify, create, or ignore values associated with each triangle’s vertex, such as its color, normal, texture coordinates, and position. Normally the vertex shader program transforms vertices from model space to homogeneous clip space (Section 4.7). At a minimum, a vertex shader must always output this location.

顶点着色器是处理三角形网格(mesh)的第一阶段。 顶点着色器无法获得描述形成哪些三角形的数据。 顾名思义，它专门处理传入的顶点。 顶点着色器提供了一种方法来修改、创建或忽略与每个三角形顶点关联的值，例如颜色、法线、纹理坐标和位置。 通常，顶点着色器程序将顶点从模型空间变换到齐次裁剪空间(homogeneous clip space)（第 4.7 节）。 至少，顶点着色器必须始终输出该位置。

A vertex shader is much the same as the unified shader described earlier. Every vertex passed in is processed by the vertex shader program, which then outputs a number of values that are interpolated across a triangle or line. The vertex shader can neither create nor destroy vertices, and results generated by one vertex cannot be passed on to another vertex. Since each vertex is treated independently, any number of shader processors on the GPU can be applied in parallel to the incoming stream of vertices.

顶点着色器与前面描述的统一着色器非常相似。 传入的每个顶点都由顶点着色器程序处理，然后输出一些值，这些值在三角形或直线上进行插值。 顶点着色器既不能创建也不能销毁顶点，一个顶点生成的结果不能传递给另一个顶点。 由于每个顶点都是独立处理的，因此 GPU 上的任意数量的着色器处理器都可以并行应用于传入的顶点流。

Input assembly is usually presented as a process that happens before the vertex shader is executed. This is an example where the physical model often differs from the logical. Physically, the fetching of data to create a vertex might happen in the vertex shader and the driver will quietly prepend every shader with the appropriate instructions, invisible to the programmer.

输入组装(Input assembly)通常呈现为在执行顶点着色器之前发生的过程。 这是一个物理模型通常与逻辑模型不同的示例。 从物理上讲，获取数据以创建顶点可能发生在顶点着色器中，驱动程序会悄悄地为每个着色器添加适当的指令，这对程序员来说是不可见的。

Chapters that follow explain several vertex shader effects, such as vertex blending for animating joints, and silhouette rendering. Other uses for the vertex shader include:

接下来的章节解释了几种顶点着色器效果，例如动画关节的顶点混合和轮廓渲染。 顶点着色器的其他用途包括：

* Object generation, by creating a mesh only once and having it be deformed by the vertex shader.
    对象生成，通过仅创建一次网格并通过顶点着色器对其进行变形。

* Animating character’s bodies and faces using skinning and morphing techniques.
    使用蒙皮(skinning)和变形技术(morphing techniques)为角色的身体和面部制作动画。

* Procedural deformations, such as the movement of flags, cloth, or water [802, 943].
    程序变形，例如旗帜、布料或水的移动 [802、943]。

* Particle creation, by sending degenerate (no area) meshes down the pipeline and having these be given an area as needed.
    粒子创建，通过在管线中发送退化（无区域）网格并根据需要为这些网格指定一个区域。

* Lens distortion, heat haze, water ripples, page curls, and other effects, by using the entire framebuffer’s contents as a texture on a screen-aligned mesh undergoing procedural deformation.
    镜头变形、热雾、水波纹、页面卷曲和其他效果，通过将整个帧缓冲区的内容用作进行程序变形的屏幕对齐网格上的纹理。

* Applying terrain height fields by using vertex texture fetch [40, 1227].
    通过使用顶点纹理获取来应用地形高度场 [40, 1227]。

Some deformations done using a vertex shader are shown in Figure 3.8.

使用顶点着色器完成的一些变形如图 3.8 所示。

![3.8](https://img-blog.csdnimg.cn/c2e8b0c525544196a6f08444c5894e74.png)


> Figure 3.8. On the left, a normal teapot. A simple shear operation performed by a vertex shader program produces the middle image. On the right, a noise function creates a field that distorts the model. (Images produced by FX Composer 2, courtesy of NVIDIA Corporation.)
> 图 3.8。 左边是一个普通的茶壶。 顶点着色器程序执行的简单剪切操作会生成中间图像。 在右侧，噪声函数(a noise function)创建了一个扭曲模型的场。 （图片由 FX Composer 2 制作，由 NVIDIA Corporation 提供。）

The output of the vertex shader can be consumed in several different ways. The usual path is for each instance’s primitives, e.g., triangles, to then be generated and rasterized, and the individual pixel fragments produced to be sent to the pixel shader program for continued processing. On some GPUs the data can also be sent to the tessellation stage or the geometry shader or be stored in memory. These optional stages are discussed in the following sections.

顶点着色器的输出可以用几种不同的方式使用。 通常的路径是每个实例的图元，例如三角形，然后被生成和光栅化，并且产生的单个像素片段被发送到像素着色器程序以进行继续处理。 在某些 GPU 上，数据还可以发送到曲面细分阶段或几何着色器或存储在内存中。 这些可选阶段将在以下部分中讨论。