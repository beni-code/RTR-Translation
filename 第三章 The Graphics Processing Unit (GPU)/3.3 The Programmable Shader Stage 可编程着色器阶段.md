## 3.3 The Programmable Shader Stage 可编程着色器阶段

Modern shader programs use a unified shader design. This means that the vertex, pixel, geometry, and tessellation-related shaders share a common programming model. Internally they have the same instruction set architecture (ISA). A processor that implements this model is called a common-shader core in DirectX, and a GPU with such cores is said to have a unified shader architecture. The idea behind this type of architecture is that shader processors are usable in a variety of roles, and the GPU can allocate these as it sees fit. For example, a set of meshes with tiny triangles will need more vertex shader processing than large squares each made of two triangles. A GPU with separate pools of vertex and pixel shader cores means that the ideal work distribution to keep all the cores busy is rigidly predetermined. With unified shader cores, the GPU can decide how to balance this load.

现代着色器程序使用统一的着色器设计。 这意味着与顶点、像素、几何和曲面细分相关的着色器共享一个通用的编程模型。 在内部，它们具有相同的指令集架构 (ISA)。 实现此模型的处理器在 DirectX 中称为通用着色器(common-shader)核心，具有此类核心的 GPU 被称为具有统一着色器架构。 这种架构背后的想法是着色器处理器可用于各种用途(roles)，GPU 可以根据需要分配它们。 例如，一组具有小三角形的网格(meshes)比每个由两个三角形组成的大正方形需要更多的顶点着色器处理。 具有独立的顶点和像素(pixel)着色器核心池的 GPU 意味着保持所有核心忙碌的理想工作分配是严格预先确定的。 使用统一的着色器核心，GPU 可以决定如何平衡这种负载。

Describing the entire shader programming model is well beyond the scope of this book, and there are many documents, books, and websites that already do so. Shaders are programmed using C-like shading languages such as DirectX’s High-Level Shading Language (HLSL) and the OpenGL Shading Language (GLSL). DirectX’s HLSL can be compiled to virtual machine bytecode, also called the intermediate language (IL or DXIL), to provide hardware independence. An intermediate representation can also allow shader programs to be compiled and stored offline. This intermediate language is converted to the ISA of the specific GPU by the driver. Console programming usually avoids the intermediate language step, since there is then only one ISA for the system.

描述整个着色器编程模型远远超出了本书的范围，许多文档、书籍和网站已经这样做了。 着色器使用类似 C 的着色语言进行编程，例如 DirectX 的高级着色语言 (HLSL) 和 OpenGL 着色语言 (GLSL)。 DirectX 的 HLSL 可以编译为虚拟机字节码，也称为中间语言（IL 或 DXIL），以提供硬件独立性。 中间表示(intermediate representation)还可以允许离线编译和存储着色器程序。 这种中间语言由驱动程序转换为特定 GPU 的 ISA(指令集架构)。

The basic data types are 32-bit single-precision floating point scalars and vectors, though vectors are only part of the shader code and are not supported in hardware as outlined above. On modern GPUs 32-bit integers and 64-bit floats are also supported natively. Floating point vectors typically contain data such as positions (xyzw), normals, matrix rows, colors (rgba), or texture coordinates (uvwq). Integers are most often used to represent counters, indices, or bitmasks. Aggregate data types such as structures, arrays, and matrices are also supported.

基本数据类型是 32 位单精度浮点标量和向量，尽管向量只是着色器代码的一部分并且在某些硬件中不受支持。 在现代 GPU 上，还原生支持 32 位整数和 64 位浮点数。 浮点向量通常包含位置 (xyzw)、法线、矩阵行(matrix rows)、颜色 (rgba) 或纹理坐标 (uvwq) 等数据。 整数最常用于表示计数器、索引或位掩码(bitmasks)。 还支持聚合(Aggregate)数据类型，例如结构、数组和矩阵。

A draw call invokes the graphics API to draw a group of primitives, so causing the graphics pipeline to execute and run its shaders. Each programmable shader stage has two types of inputs: uniform inputs, with values that remain constant throughout a draw call (but can be changed between draw calls), and varying inputs, data that come from the triangle’s vertices or from rasterization. For example, a pixel shader may provide the color of a light source as a uniform value, and the triangle surface’s location changes per pixel and so is varying. A texture is a special kind of uniform input that once was always a color image applied to a surface, but that now can be thought of as any large array of data.

绘制调用调用图形 API 来绘制一组图元，从而导致图形管道执行并运行其着色器。 每个可编程着色器阶段都有两种类型的输入：统一输入(uniform inputs)，其值在整个绘图调用期间保持不变（但可以在绘图调用之间更改），以及可变输入(varying inputs)，即来自三角形顶点或光栅化的数据。 例如，像素着色器可以提供光源的颜色作为统一值，三角形表面的位置每个像素都在变化，因此是变化的。 纹理是一种特殊的统一输入，曾经总是应用于表面的彩色图像，但现在可以将其视为任何大型数据数组(large array of data)。

The underlying virtual machine provides special registers for the different types of inputs and outputs. The number of available constant registers for uniforms is much larger than those registers available for varying inputs or outputs. This happens because the varying inputs and outputs need to be stored separately for each vertex or pixel, so there is a natural limit as to how many are needed. The uniform inputs are stored once and reused across all the vertices or pixels in the draw call. The virtual machine also has general-purpose temporary registers, which are used for scratch space. All types of registers can be array-indexed using integer values in temporary registers. The inputs and outputs of the shader virtual machine can be seen in Figure 3.3.

底层虚拟机为不同类型的输入和输出提供了特殊的寄存器。 uniform 的可用常量寄存器的数量远大于可用于变化的输入或输出的寄存器的数量。 发生这种情况是因为需要为每个顶点或像素单独存储不同的输入和输出，因此对于需要多少存在自然限制。 统一输入存储一次，并在绘制调用中的所有顶点或像素中重复使用。 虚拟机还有通用临时寄存器，用于暂存空间(scratch space)。 所有类型的寄存器都可以使用临时寄存器中的整数值进行数组索引。 着色器虚拟机的输入和输出如图 3.3 所示。

![3.3](https://img-blog.csdnimg.cn/ef7cd2d898c6415f83442689a7d2155b.png)


> Figure 3.3. Unified virtual machine architecture and register layout, under Shader Model 4.0. The maximum available number is indicated next to each resource. Three numbers separated by slashes refer to the limits for vertex, geometry, and pixel shaders (from left to right).
> 
> 图 3.3。 统一虚拟机架构和寄存器布局，在Shader Model 4.0下。 最大可用数量显示在每个资源旁边。 由斜杠分隔的三个数字指的是顶点、几何和像素着色器的限制（从左到右）。

Operations that are common in graphics computations are efficiently executed on modern GPUs. Shading languages expose the most common of these operations (such as additions and multiplications) via operators such as * and +. The rest are exposed through intrinsic functions, e.g., atan(), sqrt(), log(), and many others, optimized for the GPU. Functions also exist for more complex operations, such as vector normalization and reflection, the cross product, and matrix transpose and determinant computations.

图形计算中常见的操作可以在现代 GPU 上高效执行。 着色语言通过 * 和 + 等运算符公开这些操作中最常见的（例如加法和乘法）。 其余部分通过内部函数公开，例如 atan()、sqrt()、log() 和许多其他针对 GPU 优化的函数。 还存在用于更复杂操作的函数，例如向量归一化和反射、叉积以及矩阵转置和行列式计算。

The term flow control refers to the use of branching instructions to change the flow of code execution. Instructions related to flow control are used to implement high-level language constructs such as “if” and “case” statements, as well as various types of loops. Shaders support two types of flow control. Static flow control branches are based on the values of uniform inputs. This means that the flow of the code is constant over the draw call. The primary benefit of static flow control is to allow the same shader to be used in a variety of different situations (e.g., a varying numbers of lights). There is no thread divergence, since all invocations take the same code path. Dynamic flow control is based on the values of varying inputs, meaning that each fragment can execute the code differently. This is much more powerful than static flow control but can cost performance, especially if the code flow changes erratically between shader invocations.

术语流程控制是指使用分支指令来改变代码执行的流程。 与流程控制相关的指令用于实现高级语言结构，例如“if”和“case”语句，以及各种类型的循环。 着色器支持两种类型的流控制。 静态流控制分支基于统一输入的值。 这意味着代码流在绘制调用中是恒定(constant)的。 静态流控制的主要好处是允许在各种不同的情况下使用相同的着色器（例如，不同数量的灯光）。 没有线程分歧，因为所有调用都采用相同的代码路径。 动态流控制基于不同输入的值，这意味着每个片段可以不同地执行代码。 这比静态流控制更强大，但会降低性能，尤其是在着色器调用之间代码流变化不规律的情况下。